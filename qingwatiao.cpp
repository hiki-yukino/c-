#define CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int jump2(int n) {
	int sum;
	if (n > 2) {
		sum = 2 * jump2(n - 1);
	}
	else if (n <= 2 && n > 0) {
		return n;
	}
	else if (n <= 0) {
		printf("请输入正确的台阶总数!\n");
		return 0;
	}
	return sum;
}
int main() {
	int n, sum;
	printf("请输入台阶总数:");
	scanf_s("%d", &n);
	sum = jump2(n);
	if (sum != 0) {
		printf("青蛙的跳法总数为: %d\n", sum);
	}
	return 0;
}


//这个问题是上个问题的演化和加深，但其实理解的思路还是一样的，对于最多一次跳2级的青蛙来说，跳到最后一步时有两种可能:跳1级或者跳2级；
//对于最多一次跳3级的青蛙来说，跳到最后一步时有三种可能:跳1级或跳2级或跳3级；
//对于最多一次跳n级的青蛙来说，跳到最后一步时就有n种可能:跳1级或跳2级或跳3级…或跳n级。
//一次可以跳n级的青蛙跳倒数第二步时就有(n-1)种可能，倒数第三步有(n-2)种可能…
//假设该青蛙跳n级台阶的跳法总数为f(n)，则和第一题类似的，如果最后一步选择跳1级的话，之前就只有(n-1)级台阶可跳，
//(n-1)级的总跳法数是f(n-1)，如果最后一次跳2级的话，之前就只有(n-2)级台阶可跳，
//(n-2)级台阶的总跳法数是f(n-2)，如果最后一次跳3级的话，之前就只有(n-3)级台阶可跳，
//(n-3)级台阶的总跳法是f(n-3)…
//如果最后一次跳n级的话，之前就只有(n-n)级台阶可跳，(n-n)级台阶的总跳法是f(n-n)，
//至此也就罗列了所有的跳法可能，将以上跳法数加起来就是总的跳法数，
//即f(n)=f(n-1)+f(n-2)+f(n-3)+…+f(n-n)我们进行一下数学推导:
//f(n) = f(n - 1) + f(n - 2) + f(n - 3) + … + f(1) + f(0)------------(1)
//将n - 1代入上式
//得f(n - 1) = f(n - 2) + f(n - 3) + … + f(1) + f(0)-------------- - (2)
//由(2)式可以看出(1)式中f(n - 2) + f(n - 3) + … + f(1) + f(0)这部分的值可以用f(n - 1)替换
//则(1)式可以化简为
//f(n) = 2 * f(n - 1)

//int main()
//{                              //2.一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶
//	                       //…也可以跳上n级台阶，问它跳上一个总共n级的台阶一共有多少种跳法
//
//	return 0;
//}



//int jump(int n)
//{
//	int sum;
//	if (n > 2)
//	{
//		sum = jump(n - 1) + jump(n - 2);
//	}
//	else if (n > 0)
//	{
//		return n;
//	}
//	else if (n <= 0) 
//	{
//		printf("请输入正确的台阶总数!\n");
//		return 0;
//	}
//	return sum;
//}
//int main() {
//	int n, sum;
//	printf("请输入青蛙跳的台阶总数:");
//	scanf("%d", &n);
//	sum = jump(n);
//	if (sum != 0) 
//	{
//		printf("跳法总数为:  %d\n", sum);
//	}
//	return 0;
//}


//和汉诺塔一样，递归的思路就是把问题简化到更小规模的问题，在写程序的时候确定两个目标。
//一是如何分解一个问题，二是当该问题分解到最简时如何处理，将这两块内容通过程序告诉电脑，就可以把任务推给电脑，由电脑来解决“具体如何递推、如何回归”的问题。
//我们从最简单的情况开始分析，
//当n = 1时，青蛙只有一种跳法，也就是跳1级台阶；
//当n = 2时，青蛙有两种跳法，一种是一次跳1级，一种是一次跳两级；
//而当n = 3时，青蛙最后一次跳的时候有两种可能，一种是最后一次跳了1级，一种是最后一次跳了两级，
//这个时候我们不管青蛙前面是怎么跳的，只需要把最后一步跳1级的所有可能和最后一步跳2级的所有可能都加起来，
//就是n = 3时所有的可能性。这样就将问题分解了。
//比如当n = 10时，最后一步青蛙有两种跳法，跳1级或者跳2级，那么怎么才能跳到倒数第一步呢，
//跳完倒数第二步就该跳倒数第一步了，倒数第二步也有两种跳法，跳1级或者跳2级，怎么才能跳到倒数第二步呢，
//跳完倒数第三步…以此类推下去，到第一步或者第二步的时候我们就确切的知道了青蛙有几种跳法。
//我们将以上思路抽象成数学公式，
//令f(n)为n级台阶的总跳法数，如果最后一步选择跳1级的话，之前就只有(n - 1)级台阶可跳，
//(n - 1)级的总跳法数是f(n - 1)，如果最后一次跳2级的话，之前就只有(n - 2)级台阶可跳，
//(n - 2)级台阶的总跳法数是f(n - 2)，
//因为青蛙最后一步不是跳1级就是跳2级，所以刚刚列举的就是青蛙的所有跳法，
//即f(n) = f(n - 1) + f(n - 2).



//int jump(int n)           
//{
//	int count = 1;    
//	if (n == 1)
//	{
//		return 1;
//	}
//	else
//	{
//		
//		count=1+jump(n - 1);// 递归的最小的那个模式没找到    ××××××××
//		return count;
//	}
//
//}
//
//int main()
//{                     //一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，问这个青蛙跳上n级台阶一共有多少种跳法
//
//	int n = 0;
//	int count = 0;
//
//	scanf_s("%d", &n);
//
//	count=jump(n);
//
//	printf("%d\n", count);
//
//	return 0;
//}